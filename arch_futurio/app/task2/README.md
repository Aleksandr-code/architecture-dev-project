#### Выполнено:


#### Проект:

Реализовать операции начала и завершения длительных операций в рамках подсистемы Игровой сервер.<br>


Поступательное движение и поворот - это длительные операции. 
Под длительностью здесь понимается не то, что время их выполнения может быть минуты, часы или годы. 
Длительность, с точки зрения вычислимости, описанной дейкстрой (см. занятие №1) означает, что мы можем наблюдать промежуточное состояние этого объекта в процессе выполнения длительной операции. 
Другими словами длительная операция - это операция, которая выполняется не атомарным образом. 
А значит у этой операции есть начало и конец. 
В рамках этого домашнего задания предстоит реализовать операции начала длительной операции Start и завершения длительной операции End.
<br>


Для реализации этой задачи предположим, что у нас все операции, например, move, rotate, имеют один общий интерфейс:<br>

<pre> <code>
interface Command 
{
   void Execute(); 
}
</code></pre>



Все команды игры хранятся в очереди Queue. 
Как будет производиться работа с очередью - будет определено в следующих ДЗ. 
Сейчас достаточно считать, что результат работы команды Start Заключается в том, что команда, например, Move или Rotate, ставится в очередь, а результат команды End заключается в том, что соответствующая команда, например,  Move или Rotate, удаляется из очереди команд.<br>

Definition of Done критерии
Complexity Level #1:
1. Реализована операция StartMoveCommand<br>
   1.1. Определен интерфейс MoveCommandStartable, с помощью которого можно получить экземпляр UObject - объект, который будет двигаться по прямой, целочисленное значение Velocity - модуль мгновенной скорости, с которой начинает двигаться объект, Queue<Command> - очередь команд, куда будет записана команда созданная команда Move.

<pre><code>
!Обратить внимание. Интерфейс MoveCommandStartable будет оберткой не над космическим кораблем или торпедой, а над приказом, который главнокомандующий флотом отправляет своему кораблю. Этот приказ тоже будет представлен UObject (приказ передается от одного процесса к другому и требует сериализации.десериализации). Приказ можно представить себе как следующий json-объект:
{
“id”: “уникальный идентификатор объекта, которому отдан приказ”,
“action”: “код операции”, //например, “startMove”, “stopMove”, “fire” и т.д.
// параметры, специфичные для самого приказа
“velocity”: 2
}
</code></pre><br>

1.2. Реализована команда StartMoveCommand, которая
* записывает значение скорости в движущийся объект,<br>
  !Указание. Изменение скорости лучше сделать через отдельную команду, для которой определен отдельный интерфейс для изменения скорости.<br>
* создает адаптер MovableAdapter для движущегося объекта,
* создает команду MoveCommand
* кладет команду MoveCommand в очередь
2. Реализована операция EndMoveCommand<br><br> 
   2.1. Реализован интерфейс MoveCommandEndable, который возвращает команду Move, которую необходимо завершить, объект, который движется с помощью данной команды, очередь команд Queue<Command><br><br>
   2.2. Реализована команда EndMoveCommand, которая
* удаляет значение скорости из движущегося объекта.<br>
  !Указание. Самая простая реализация потребует добавление в интерфейс UObject метода, который удаляет значение по ключу. Вообще, это является нарушением OCP, но предлагаю сделать сейчас так, чтобы не усложнять понимание всего процесса работы с SOLID на данном этапе обучения.<br>
* удаляет команду Move из Очереди команд.<br>
  !Указание. Это не самый оптимальный вариант реализации, так как потребует просматривать команды, которые находятся в очереди и временные затраты на эту операцию будут пропорциональны длине очереди.<br>
3. Код решения опубликован на github/gitlab в отдельной ветке.
4. Код компилируется без ошибок


Complexity Level #2:
5. Команды StartMoveCommand и EndMoveCommand покрыты тестами с коэффициентом покрытия 100%.
6. Все тесты успешно выполняются.


Complexity Level #3:
7. Реализована операция StartRotateCommand
8. Реализована операция EndRotateCommand
9. Команды StartMoveCommand и StartRotateCommand обобщены до одной команды StartCommand.
10. Команды EndMoveCommand и EndRotateCoammnd обощены до одной команды EndCommand.


Complexity Level #4:
11. Команда EndCommand реализована не оптимально, так как просматривает очередь для поиска и удалении соответствующей команды.<br>
    Реализовать операцию удаления за константное время.<br>
    !Указание. Удаляемая команда должна быть реализована с помощью паттерна Bridge. Команда хранит внутри ссылку на команду, которая и обеспечивает необходимое действие. При удалении - удаляется не сама команда, а переписывается ссылка на внутреннюю команду - вместо нее записывается ссылка на команду, которая ничего не делает.  Пример реализации команды по паттерну Bridge:<br>
   <pre><code>
class BridgeCommand: Command, InjectableCommand
{
    Command internalCommand;
    public BridgeCommand(Command internal)
    {
      internalCommand = internal;
    }
    

   public Inject(Command other)
   {
      internalCommand = other;
   }
   
   
   public void Execute()
   {
      internalCommand.Exevute();
   }
}
</code></pre> 

